// See /authentication/README.md for details about this app

const fs = require('fs').promises
const http = require('http')
const https = require('https')
const path = require('path')
const url = require('url')

const buildUrl = (protocol, host, port) => {
  let url = `${protocol}://${host}`
  if (port) url += `:${port}`
  return url
}

const CLIENT_ID = process.env.CLIENT_ID
const CLIENT_SECRET = process.env.CLIENT_SECRET
const CLIENT_SCOPE = process.env.SCOPE || 'all'
const CLIENT_STATE = Math.random().toString(36).substr(2) // a random token generated by the client app, protects against CSRF

const APP_PROTOCOL = 'http'
const APP_HOST = 'localhost'
const APP_PORT = 8000
const APP_BASE_URL = buildUrl(APP_PROTOCOL, APP_HOST, APP_PORT)
const APP_CALLBACK_URI = `${APP_BASE_URL}/authenticate/callback`

const FIELDAGENT_PROTOCOL = process.env.FIELDAGENT_PROTOCOL || 'https'
const FIELDAGENT_HOST = process.env.FIELDAGENT_HOST || 'apistaging.sentera.com'
const FIELDAGENT_PORT = process.env.FIELDAGENT_PORT
const FIELDAGENT_BASE_URL = buildUrl(FIELDAGENT_PROTOCOL, FIELDAGENT_HOST, FIELDAGENT_PORT)
const FIELDAGENT_AUTH_URL = `${FIELDAGENT_BASE_URL}/oauth/authorize`
const FIELDAGENT_OAUTH_TOKEN_PATH = '/oauth/token'
const FIELDAGENT_GRAPHQL_PATH = '/graphql'

const INDEX_HTML = 'index.html'
const FIELDS_HTML = 'fields.html'
const NOT_FOUND_HTML = '404.html'

const requiredEnvVars = [
  { name: 'CLIENT_ID', value: CLIENT_ID },
  { name: 'CLIENT_SECRET', value: CLIENT_SECRET }
]
requiredEnvVars.forEach(envVar => {
  if (!envVar.value) {
    const message = `${envVar.name} environment variable not defined. Request this value from Sentera by sending an email to devops@sentera.com.`
    console.log(message)
    process.exit(1)
  }
})

const fieldAgent = FIELDAGENT_PROTOCOL === 'https' ? https : http

const requestListener = (clientRequest, clientResponse) => {
  // Process requests made by this demo app's web UI
  clientResponse.setHeader('Content-Type', 'text/html')

  const clientRequestInfo = new url.URL(clientRequest.url, APP_BASE_URL)
  const path = clientRequestInfo.pathname
  console.log(`Process ${path} request`)

  switch (path) {
    case '/':
      handleIndexRequest(clientResponse)
      break

    case '/authenticate':
      handleAuthenticationRequest(clientResponse)
      break

    case '/authenticate/callback':
      handleAuthenticationCallback(clientRequestInfo, clientResponse)
      break

    default: {
      // Requested path does not exist
      clientResponse.writeHead(404)
      const html = htmlFiles[NOT_FOUND_HTML].replace('%{path}', path)
      clientResponse.end(html)
    }
  }
}

const server = http.createServer(requestListener)

// Read the HTML files used by this app into memory,
// and then start the server

const htmlFiles = {}
const htmlFileNames = [INDEX_HTML, FIELDS_HTML, NOT_FOUND_HTML]
const promises = htmlFileNames.map(filename => (
  fs.readFile(path.join(__dirname, filename))
    .then(contents => {
      htmlFiles[filename] = contents.toString()
    })
    .catch(error => {
      console.error(`Could not read ${filename}: ${error}`)
      process.exit(1)
    })
))

Promise.all(promises).then(() => {
  server.listen(APP_PORT, APP_HOST, () => {
    console.log(`Local server is running on ${APP_BASE_URL}. It will use FieldAgent at ${FIELDAGENT_BASE_URL}.`)
  })
})

// Request Handler Functions

const handleIndexRequest = (clientResponse) => {
  clientResponse.writeHead(200)
  const html = htmlFiles[INDEX_HTML].replace('%{error}', '')
  clientResponse.end(html)
}

const handleAuthenticationRequest = (clientResponse) => {
  // To retrieve fields from FieldAgent, we need to get an
  // access token so we can call the FieldAgent GraphQL API.
  // Initiate the OAuth authorization code grant workflow
  // by redirecting the browser to FieldAgent for authentication.
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: CLIENT_ID,
    scope: CLIENT_SCOPE,
    state: CLIENT_STATE,
    redirect_uri: APP_CALLBACK_URI
  }).toString()
  clientResponse.writeHead(302, {
    Location: FIELDAGENT_AUTH_URL + '?' + params
  })
  clientResponse.end()
}

const handleAuthenticationCallback = (clientRequestInfo, clientResponse) => {
  // After the user successfully authenticates with
  // FieldAgent and grants this app access to the user's
  // fields, FieldAgent will redirect back to this app
  // using the redirect_uri parameter we supplied on the
  // authentication request. The redirect will contain
  // an authentication code. We need to exchange this
  // code for an access token, so we can call the
  // FieldAgent GraphQL API to get the user's fields.

  const params = new URLSearchParams(clientRequestInfo.search)
  const code = params.get('code')
  const state = params.get('state')
  const error = params.get('error')
  let errorDescription = params.get('error_description')
  if (!error && state !== CLIENT_STATE) {
    // State provided in the redirect does not match
    // the state sent with the authentication request.
    // Possible CSRF attack.
    errorDescription = 'State parameter does not match client state.'
  }
  if (errorDescription) {
    clientResponse.writeHead(200)
    const html = htmlFiles[INDEX_HTML].replace('%{error}', errorDescription)
    clientResponse.end(html)
    return
  }

  exchangeCodeForAccessToken(code, clientResponse)
}

const exchangeCodeForAccessToken = (code, clientResponse) => {
  const params = {
    host: FIELDAGENT_HOST,
    port: FIELDAGENT_PORT,
    path: FIELDAGENT_OAUTH_TOKEN_PATH,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    }
  }

  const fieldAgentRequest = fieldAgent.request(params, (fieldAgentResponse) => {
    let fieldAgentResponseStr = ''

    // A chunk of data has been received
    fieldAgentResponse.on('data', (chunk) => {
      fieldAgentResponseStr += chunk
    })

    // The whole response has been received
    fieldAgentResponse.on('end', () => {
      const fieldAgentResponseData = JSON.parse(fieldAgentResponseStr)
      console.log('Exchange code for access token response')
      console.log(fieldAgentResponseData)

      // Other things are returned but for the purposes of
      // this demo we only care about the access token
      const accessToken = fieldAgentResponseData.access_token

      // Call the FieldAgent GraphQL API to get the user's fields
      readFieldsInFieldAgent(accessToken, clientResponse)
    })
  })

  // Request to exchange the authentication code for an access token
  const data = {
    grant_type: 'authorization_code',
    client_id: CLIENT_ID,
    client_secret: CLIENT_SECRET,
    code,
    redirect_uri: APP_CALLBACK_URI
  }
  fieldAgentRequest.write(JSON.stringify(data))
  fieldAgentRequest.end()
}

const readFieldsInFieldAgent = (accessToken, clientResponse) => {
  const params = {
    host: FIELDAGENT_HOST,
    port: FIELDAGENT_PORT,
    path: FIELDAGENT_GRAPHQL_PATH,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${accessToken}`
    }
  }

  const fieldAgentRequest = fieldAgent.request(params, (fieldAgentResponse) => {
    let fieldAgentResponseStr = ''

    // A chunk of data has been received
    fieldAgentResponse.on('data', (chunk) => {
      fieldAgentResponseStr += chunk
    })

    // The whole response has been received
    fieldAgentResponse.on('end', () => {
      const fieldAgentResponseData = JSON.parse(fieldAgentResponseStr)
      console.log('Get fields response')
      console.log(fieldAgentResponseData)

      // Build a response with the user's fields to send to the browser
      let totalNumFields = 0
      let fieldRows = []
      let error = ''
      if (fieldAgentResponseData.data) {
        const fields = fieldAgentResponseData.data.fields
        totalNumFields = fields.total_count
        fieldRows = fields.results.map(field => `<tr><td>${field.sentera_id}</td><td>${field.name}</td><td>${field.latitude}</td><td>${field.longitude}</td></tr>`).join('')
      } else if (fieldAgentResponseData.errors) {
        const errors = fieldAgentResponseData.errors
        error = errors[0].message
      } else if (fieldAgentResponseData.message) {
        error = fieldAgentResponseData.message
      } else {
        error = 'An unexpected error returned by FieldAgent, check the web server output in the console'
      }
      const html = htmlFiles[FIELDS_HTML].replace('%{num_fields}', totalNumFields).replace('%{fields}', fieldRows).replace('%{error}', error)
      clientResponse.writeHead(200)
      clientResponse.end(html)
    })
  })

  // Request the user's fields (first 50)
  const gqlQuery = `
    query AllFields {
      fields(
        pagination: {
          page: 1
          page_size: 50
        }
      ) {
        total_count
        results {
          sentera_id
          name
          latitude
          longitude
        }
      }
    }
  `
  const data = { query: gqlQuery }
  fieldAgentRequest.write(JSON.stringify(data))
  fieldAgentRequest.end()
}
