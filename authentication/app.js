// See /authentication/README.md for details about this app

const fs = require('fs').promises
const http = require("http")
const https = require("https")
var url = require('url')

const CLIENT_ID = process.env.CLIENT_ID
const CLIENT_SECRET = process.env.CLIENT_SECRET
const CLIENT_SCOPE = process.env.SCOPE || 'read_fields'
const CLIENT_STATE = Math.random().toString(36).substr(2) // a random token generated by the client app, protects against CSRF

const APP_PROTOCOL = 'http'
const APP_HOST = 'localhost'
const APP_PORT = 8000
const APP_BASE_URL = `${APP_PROTOCOL}://${APP_HOST}:${APP_PORT}`
const APP_CALLBACK_URI = `${APP_BASE_URL}/authenticate/callback`

const FIELDAGENT_PROTOCOL = process.env.FIELDAGENT_PROTOCOL || 'https'
const FIELDAGENT_HOST = process.env.FIELDAGENT_HOST || 'api.sentera.com'
const FIELDAGENT_PORT = process.env.FIELDAGENT_PORT || ''
const FIELDAGENT_BASE_URL = `${FIELDAGENT_PROTOCOL}://${FIELDAGENT_HOST}:${FIELDAGENT_PORT}`
const FIELDAGENT_AUTH_URL = `${FIELDAGENT_BASE_URL}/oauth/authorize`
const FIELDAGENT_OAUTH_TOKEN_PATH = '/oauth/token'
const FIELDAGENT_GRAPHQL_PATH = '/graphql'

const INDEX_HTML = 'index.html'
const FIELDS_HTML = 'fields.html'
const NOT_FOUND_HTML = '404.html'

const requiredEnvVars = [
  { name: 'CLIENT_ID', value: CLIENT_ID },
  { name: 'CLIENT_SECRET', value: CLIENT_SECRET }
]
requiredEnvVars.forEach(envVar => {
  if (!envVar.value) {
    const message = `${envVar.name} environment variable not defined. Request this value from Sentera by sending an email to api-support@sentera.com.`
    console.log(message)
    process.exit(1)
  }
})

const fieldAgent = FIELDAGENT_PROTOCOL === 'https' ? https : http

const requestListener = (clientRequest, clientResponse) => {
  // Process requests made by this demo app's web UI
  clientResponse.setHeader("Content-Type", "text/html")

  const clientRequestInfo = url.parse(clientRequest.url, true)
  const path = clientRequestInfo.pathname
  console.log(`Process ${path} request`)

  switch (path) {
    case '/':
      handleIndexRequest(clientResponse)
      break

    case '/authenticate':
      handleAuthenticationRequest(clientResponse)
      break

    case '/authenticate/callback':
      handleAuthenticationCallback(clientRequestInfo, clientResponse)
      break

    default:
      // Requested path does not exist
      clientResponse.writeHead(404)
      const html = htmlFiles[NOT_FOUND_HTML].replace('%{path}', path)
      clientResponse.end(html)
  }
}

const server = http.createServer(requestListener)

// Read the HTML files used by this app into memory,
// and then start the server

const htmlFiles = {}
const htmlFileNames = [INDEX_HTML, FIELDS_HTML, NOT_FOUND_HTML]
const promises = htmlFileNames.map(filename => (
  fs.readFile(`${__dirname}/${filename}`)
    .then(contents => {
      htmlFiles[filename] = contents.toString()
    })
    .catch(error => {
      console.error(`Could not read ${filename}: ${error}`)
      process.exit(1)
    })
))

Promise.all(promises).then(() => {
  server.listen(APP_PORT, APP_HOST, () => {
    console.log(`Server is running on ${APP_BASE_URL}`)
  })
})

// Request Handler Functions

const handleIndexRequest = (clientResponse) => {
  clientResponse.writeHead(200)
  const html = htmlFiles[INDEX_HTML].replace('%{error}', '')
  clientResponse.end(html)
}

const handleAuthenticationRequest = (clientResponse) => {
  // To retrieve fields from FieldAgent, we need to get an
  // access token so we can call the FieldAgent GraphQL API.
  // Initiate the OAuth authentication code grant workflow
  // by redirecting the browser to FieldAgent for authentication.
  const params = new URLSearchParams({
    'response_type': 'code',
    'client_id': CLIENT_ID,
    'scope': CLIENT_SCOPE,
    'state': CLIENT_STATE,
    'redirect_uri': APP_CALLBACK_URI
  }).toString();
  clientResponse.writeHead(302, {
    'Location': FIELDAGENT_AUTH_URL + '?' + params
  });
  clientResponse.end();
}

const handleAuthenticationCallback = (clientRequestInfo, clientResponse) => {
  // After the user successfully authenticates with
  // FieldAgent and grants this app access to the user's
  // fields, FieldAgent will redirect back to this app
  // using the redirect_uri parameter we supplied on the
  // authentication request. The redirect will contain
  // an authentication code. We need to exchange this
  // code for an access token, so we can call the
  // FieldAgent GraphQL API to get the user's fields.

  const params = new URLSearchParams(clientRequestInfo.search)
  const code = params.get('code')
  const state = params.get('state')
  const error = params.get('error')
  let errorDescription = params.get('error_description')
  if (!error && state !== CLIENT_STATE) {
    // State provided in the redirect does not match
    // the state sent with the authentication request.
    // Possible CSRF attack.
    errorDescription = 'State parameter does not match client state.'
  }
  if (errorDescription) {
    clientResponse.writeHead(200)
    const html = htmlFiles[INDEX_HTML].replace('%{error}', errorDescription)
    clientResponse.end(html)
    return
  }

  exchangeCodeForAccessToken(code, clientResponse)
}

const exchangeCodeForAccessToken = (code, clientResponse) => {
  const params = {
    host: FIELDAGENT_HOST,
    port: FIELDAGENT_PORT,
    path: FIELDAGENT_OAUTH_TOKEN_PATH,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    }
  }

  const fieldAgentRequest = fieldAgent.request(params, (fieldAgentResponse) => {
    let fieldAgentResponseStr = ''

    // A chunk of data has been received
    fieldAgentResponse.on('data', (chunk) => {
      fieldAgentResponseStr += chunk;
    })

    // The whole response has been received
    fieldAgentResponse.on('end', () => {
      const fieldAgentResponseData = JSON.parse(fieldAgentResponseStr)
      console.log('Exchange code for access token response')
      console.log(fieldAgentResponseData)

      // Other things are returned but for the purposes of
      // this demo we only care about the access token
      const accessToken = fieldAgentResponseData.access_token

      // Call the FieldAgent GraphQL API to get the user's fields
      readFieldsInFieldAgent(accessToken, clientResponse)
    })

  }).on("error", (error) => {
    throw `Error: ${error.message}`
  })

  // Request to exchange the authentication code for an access token
  const data = {
    'grant_type': 'authorization_code',
    'client_id': CLIENT_ID,
    'client_secret': CLIENT_SECRET,
    'code': code,
    'redirect_uri': APP_CALLBACK_URI
  }
  fieldAgentRequest.write(JSON.stringify(data))
  fieldAgentRequest.end()
}

const readFieldsInFieldAgent = (accessToken, clientResponse) => {
  const params = {
    host: FIELDAGENT_HOST,
    port: FIELDAGENT_PORT,
    path: FIELDAGENT_GRAPHQL_PATH,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${accessToken}`
    }
  }

  const fieldAgentRequest = fieldAgent.request(params, (fieldAgentResponse) => {
    let fieldAgentResponseStr = ''

    // A chunk of data has been received
    fieldAgentResponse.on('data', (chunk) => {
      fieldAgentResponseStr += chunk;
    })

    // The whole response has been received
    fieldAgentResponse.on('end', () => {
      const fieldAgentResponseData = JSON.parse(fieldAgentResponseStr)
      console.log('Get fields response')
      console.log(fieldAgentResponseData)

      // Build a response with the user's fields to send to the browser
      const fields = fieldAgentResponseData.data.fields
      const numFields = fields.total_count
      const fieldRows = fields.results.map(field => `<tr><td>${field.sentera_id}</td><td>${field.name}</td><td>${field.latitude}</td><td>${field.longitude}</td></tr>`).join('')
      const html = htmlFiles[FIELDS_HTML].replace('%{num_fields}', numFields).replace('%{fields}', fieldRows)
      clientResponse.writeHead(200)
      clientResponse.end(html)
    })
  }).on("error", (error) => {
    throw `Error: ${error.message}`
  })

  // Request the user's fields
  const gqlQuery = `
    query AllFields {
      fields {
        total_count
        results {
          sentera_id
          name
          latitude
          longitude
        }
      }
    }
  `
  const data = { 'query': gqlQuery }
  fieldAgentRequest.write(JSON.stringify(data))
  fieldAgentRequest.end()
}
